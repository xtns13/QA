git - проверка установки гита под виндой
copy NUL .gitconfig - создание конфига для гита, куда запишем данные авторизации, именно эти параметры будут записываться в репозиторий, когда мы будем вносить изменения
[user]
	email=
	name=
git config --list --global - проверка созданного конфига
git clone https://github.com/..... - клонирование ерпозитория на локальную мшину
git status - выдача статуса гита, проверка, что репозиторий виден
touch some.file - создать пустой файл
git status - видим наш файл, он подствечен и находиться в списке untracked это файл который был создан локально и еще не принадлежит репозиторию, т.е. наша система гит о таком файле еще ничего не знает, она просто его видит.
echo "Hello git" >> some.file внести данные в файл
cat some.file - вывести содержимое файла  в консоль
git add some.file знакомим нашу систему с файлом, она узнает и начинает отслеживать все, что с ним происходит
git status - теперь этот файл будет зеленым и находится в спсике new file, это такой файл, о котором наша система уже знает, но он для нее новый, без истории
внесем изменения в файл echo "line" >> some.file и статус у него станет как new file так и modified (это файл, о котором наша система знает и знает, что в нем произошли изменения)
git add some.file - применяем изменения и теперь он останется только в одном состоянии new file
пока мы не воложим его на удаленный сервер он будет new file
commit - это единица состояние нашего проекта, мы можем пеерключаться между коммитами
git commit -m "my first commit" - локальный репозиторий переключился именно на это состояние проекта, теперь файл не новый и не модифицированный, теперь по команде status информация о файле выводиться не будет, но это все просиходит н алокальном клиенте, теперь его надо выложить изменения на сервер, чтобы все могли их видеть
git push - заливаем на удаленный сервер изменения
git fetch - команда, чтобы узнать есть ли изменения на удаленном репозитории
master - локальная рабочая ветка, на нашей машине и именно в нее мы вносим все изменения
origin master - версия ветки на удаленном репозитории, из maser мы заливаем изменения в origin master
origin/master тоже локальная, но не рабочая версия ветки, в ней храниться информация о том что мы знали об origin master на момент последнего выполнения команды git fetch, нужна для понимания того, в каком состоянии находится наша локальная ветка относительно origin, когда мы делаем git getch именно в origin/master поступает инфомрация, наша ветка master на этом этапе ника кне меняется.
fast forward - одна из стратегий слияния локальной и удаленной ветки проекта, когда меняется предок 
git pull - стягиваем с репозитория, чтобы обновить нашу локальную ветку
Каждый раз, когда мы что-то коммитим, формируется хеш коммита, это уникальный набор символов, чтобы можно было переключаться между коммитами и смотреть какие изменения были сделаны в том или ином коммите.
git log - выводит историю всех изменений нашего репозитория
git log --autor xxxxx - показать коммиты конкретного автора
git show xxxx - где хххх - хеш коммита, для вывода информации о конкретному коммите
git show - команда выполниться для последнего коммита ветки
git blame some.file - команда, чтобы посмотреть автора файла, можно сиспользовать вместе с командой grep, чтобы узнать кто был автором конкретной строки.
git diff - узнать что было изменено в файле
git commit -a -m "some change" (-a означает добавить все файлы)
git reset HEAD~1 - чтобы сдвинуть HEAD на одну позицию, в выводе увидим какие файлы оказались разобранными, коммит пропадет из истории
git reset HEAD~1 --hard - с этим ключем все разобранные изменения удаляются, если мы передумали что-то выкладыать совсем
git commit --amend (--amend - ключ, чтобы изменить коммит, откроется редактор)
git add second.file
статус both modified - когда один и тот же файл был изменен как локально так и в репозитории, в таком случае будет конфликт и не даст запушить
git merge --abort - отменить слияние
git add some.file - чтобы смержить файл и показать гиту, что мы разобрались с файлом, после правки конфликтной ситуации.
Иногда мы делаем изменения и в какой-то момент понимаем, что они нам не нужны, тогда 
git checkout some.file - это команда возвращает указанный файл к состоянию, в котором он был до начала изменения, т.е. на момент последнего коммита.
git checkout . (оменить все изменения в текущей директории)
checkcout отменяет изменения на совсем, если нам нужно временно отменить изменения то используем: git stash
, а когда нам потребуется венуть сохраненное изменение то мы используем команду, которая достанет сохраненные изменения: git stash pop
git stash clear - удалить сохраненные изменения из stash
можно сделать изменения в основном файле, потом запсиать эти измемнения в файл git diff >> some.patch, и отменить измнения в основном файле с помощью git checkout. В рузельтате получим нетронутые основном файл и файл с патч с изменениями, который мы сможем потом применить, если потребуется при помощи git apply some.patch. Обычно используется для той части кода, где изменения очень редкие или для временного хранения каких-то правок

git branch my_first_branch - осздать ветку
git branch - выведет список веток
git checkout my_first_branch - переключиться на ветку
git push -u origin my_first_branch - запушить изменения и связать локальную ветку с веткой в репозитории
git checkout - (переключиться на предыдущую ветку)
git merge my_first_branch (вмержить в текущую ветку указанную ветку в команде) Команда merge только изменила локальную ветку мастера, добаив в нее коммит из ветки my_first_branch, затем как обычно делаем git push
git branch -m my_first_branch new_name - переименование ветки в new_branch с ключем -m
git push origin : my_first_branch - удаление ветки в удаленном репозитории. Очень важно перед тем как удалять ветку с удаленного репозитория, стянуть с нее все изменения в локальный репозиторий
git branch -d some_branch - удаление ветки локально
git fetch origin some_origin_branch - стянуть ветку с удаленого ерпозитория, которой у нас еще нет, потом надо на нее переключиться git checkout some_origin_branch - чтобы она появилась в списке наших локальных вветок

git add . - добавить все untraсked файлы
git reset HEAD some.file - вернуть какой-либо файл обратно в статус untracked
git reset HEAD - отменить все изменения
git clean -f - удалить все untracked файлы

.gitignore - конфигурационный файл где перечень файлов, которые не будут появляться в гит даже в списке untracked файлов
echo some.file > .gitignore
можно добавлять файлы и по маске echo *.file >> .gitignore
Работа с директориями в гите ничем не отличается от работы с файлами, единственное отличие, что мы примменяем изменения ко всем файлам, находящимся в директории.
Для того, чтобы удалить директорию из untracked вместе с ключем -f нужен еще ключ -d, и если она не пуста до удалиться тоже.
git clean -f -d

git grep Line - поиск
git grep -n Line - покажет стрчоку где всетрчается строка
git grep -c Line - покажет сколько раз встречается строка
git grep -e one -e two - поиск по двум элементам
git grep -i Line - игнорирование регистра
git grep --help - инфор по команде

.gitconfig
cat ~/.gitconfig
cat C\Users\xxxxx\.gitconfig
cat .git/config - конфиг в директории локального репозитория, в первую очередь там храниться информация о нашем origin, о каждой ветке. Данные указанны в этом конфиге приорететней данных в файле .gitconfig

Алиасы, редактируем .gitconfig
[alias]
	co = checkout
	br = branch

Git flow - подкход к управлению ветками гита
Две ветки master и develop, в мастере тот же код, что и в рабочей версии проекта. А вся работа делается в ветке develop, от которой создаются features ветки, и есть ветка release, которая используется для подкготовки к новому релизу, есть ветка hotfix, служит для срочного исправления багов. Когда возникает необходимость обробовать новый функционал создается feature ветка, закончим работу на feature ветке, ее сливают с develop, потом перемещается в ветку release, где будет проходить правка багов, потом сливается в мастер. Так же этот релиз можно отметить и на develop ветке.





















